# [Debugging With GDB](https://sourceware.org/gdb/onlinedocs/gdb/index.html)

- [Debugging With GDB](#debugging-with-gdb)
  - [9 Examining Source Files](#9-examining-source-files)
    - [9.1 Printing Source Lines](#91-printing-source-lines)
    - [9.2 Specifying a Location](#92-specifying-a-location)
    - [9.3 Editing Source Files](#93-editing-source-files)
    - [9.4 Searching Source Files](#94-searching-source-files)
    - [9.5 Specifying Source Directories](#95-specifying-source-directories)
    - [9.6 Source and Machine Code](#96-source-and-machine-code)
  - [11 Debugging Optimized Code](#11-debugging-optimized-code)
    - [11.1 Inline Functions](#111-inline-functions)
    - [11.2 Tail Call Frames](#112-tail-call-frames)
  - [20 Debugging Remote Programs](#20-debugging-remote-programs)
    - [20.1 Connecting to a Remote Target](#201-connecting-to-a-remote-target)
      - [Types of Remote Connections](#types-of-remote-connections)
      - [Host and Target Files](#host-and-target-files)
      - [Remote Connection Commands](#remote-connection-commands)
    - [20.2 Sending files to a remote system](#202-sending-files-to-a-remote-system)
    - [20.3 Using the gdbserver Program](#203-using-the-gdbserver-program)
      - [Running `gdbserver`](#running-gdbserver)
      - [Attaching to a Running Program](#attaching-to-a-running-program)
      - [Connecting to `gdbserver`](#connecting-to-gdbserver)
    - [20.4 Remote Configuration](#204-remote-configuration)
    - [20.5 Implementing a Remote Stub](#205-implementing-a-remote-stub)

## [9 Examining Source Files](https://sourceware.org/gdb/onlinedocs/gdb/Source.html)

GDB can print parts of your program’s source, since the debugging information recorded in the program tells GDB what source files were used to build it.

### [9.1 Printing Source Lines](https://sourceware.org/gdb/onlinedocs/gdb/List.html)

To print lines from a source file, use the `list` command (abbreviated `l`).

### [9.2 Specifying a Location](https://sourceware.org/gdb/onlinedocs/gdb/Specify-Location.html)

### [9.3 Editing Source Files](https://sourceware.org/gdb/onlinedocs/gdb/Edit.html)

### [9.4 Searching Source Files](https://sourceware.org/gdb/onlinedocs/gdb/Search.html)

### [9.5 Specifying Source Directories](https://sourceware.org/gdb/onlinedocs/gdb/Source-Path.html)

Executable programs sometimes do not record the directories of the source files from which they were compiled, just the names. Even when they do, the directories could be moved between the compilation and your debugging session. GDB has a list of directories to search for source files; this is called the `source path`. Each time GDB wants a source file, it tries all the directories in the list, in the order they are present in the list, until it **finds a file with the desired name**.

The source path will always include two special entries ‘`$cdir`’ and ‘`$cwd`’, these refer to the compilation directory (if one is recorded) and the current working directory respectively. 

If a compilation directory is recorded in the debug information, and GDB has not found the source file after the first search using `source path`, then GDB will combine the compilation directory and the filename, and then search for the source file again using the `source path`.

Whenever you reset or rearrange the source path, GDB clears out any information it has cached about where source files are found and where each line is in the file.

When you start GDB, its source path includes only ‘`$cdir`’ and ‘`$cwd`’, in that order. To add other directories, use the `directory` command.

### [9.6 Source and Machine Code](https://sourceware.org/gdb/onlinedocs/gdb/Machine-Code.html)

## [11 Debugging Optimized Code](https://sourceware.org/gdb/onlinedocs/gdb/Optimized-Code.html)

Almost all compilers support optimization. With optimization disabled, the compiler generates assembly code that corresponds directly to your source code, in a simplistic way. As the compiler applies more powerful optimizations, the generated assembly code diverges from your original source code. With help from debugging information generated by the compiler, GDB can map from the running program back to constructs from your original source.

GDB is more accurate with optimization disabled. If you can recompile without optimization, it is easier to follow the progress of your program during debugging. But, there are many cases where you may need to debug an optimized version.

When you debug a program compiled with ‘`-g -O`’, remember that the optimizer has rearranged your code; the debugger shows you what is really there. Do not be too surprised when the execution path does not exactly match your source file! An extreme example: if you define a variable, but never use it, GDB never sees that variable—because the compiler optimizes it out of existence.

### [11.1 Inline Functions](https://sourceware.org/gdb/onlinedocs/gdb/Inline-Functions.html)

### [11.2 Tail Call Frames](https://sourceware.org/gdb/onlinedocs/gdb/Tail-Call-Frames.html)

## [20 Debugging Remote Programs](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Debugging.html)

### [20.1 Connecting to a Remote Target](https://sourceware.org/gdb/onlinedocs/gdb/Connecting.html)

#### Types of Remote Connections

- With target remote mode
- With target extended-remote mode

#### Host and Target Files

GDB, running on the host, needs access to **symbol and debugging information** for your program running on the target. This requires access to an unstripped copy of your program, and possibly any associated symbol files.

If the remote program is stripped, or the target does not support remote program file access, start up GDB using the name of the local unstripped copy of your program as the first argument, or use the `file` command.

The symbol file and target libraries must **exactly match** the executable and libraries on the target, with one exception: the files on the host system should not be stripped, even if the files on the target system are. Mismatched or missing files will lead to confusing results during debugging. On GNU/Linux targets, mismatched or missing files may also prevent gdbserver from debugging multi-threaded programs.

#### Remote Connection Commands

Debug using a TCP connection to `port` on `host`

    target remote host:port
    target remote [host]:port
    target remote tcp:host:port
    target remote tcp:[host]:port
    target remote tcp4:host:port
    target remote tcp6:host:port
    target remote tcp6:[host]:port
    target extended-remote host:port
    target extended-remote [host]:port
    target extended-remote tcp:host:port
    target extended-remote tcp:[host]:port
    target extended-remote tcp4:host:port
    target extended-remote tcp6:host:port
    target extended-remote tcp6:[host]:port

If your remote target is actually running on the **same machine** as your debugger session (e.g. a simulator for your target running on the same host), you can omit the hostname. For example, to connect to port 1234 on your local machine:

    target remote :1234

Debug using UDP packets to `port` on `host`

    target remote udp:host:port
    target remote udp:[host]:port
    target remote udp4:host:port
    target remote udp6:[host]:port
    target extended-remote udp:host:port
    target extended-remote udp:host:port
    target extended-remote udp:[host]:port
    target extended-remote udp4:host:port
    target extended-remote udp6:host:port
    target extended-remote udp6:[host]:port

When you have finished debugging the remote program, you can use the `detach` command to **release it from GDB control**. Detaching from the target normally resumes its execution, but the results will depend on your particular remote stub. After the `detach` command in `target remote` mode, GDB is free to connect to another target. In `target extended-remote` mode, GDB is still connected to the target.

The `disconnect` command closes the connection to the target, and the target is generally not resumed. It will wait for GDB (this instance or another one) to connect and continue debugging. After the `disconnect` command, GDB is again free to connect to another target.

### [20.2 Sending files to a remote system](https://sourceware.org/gdb/onlinedocs/gdb/File-Transfer.html)

Some remote targets offer the ability to transfer files over the same connection used to communicate with GDB.

### [20.3 Using the gdbserver Program](https://sourceware.org/gdb/onlinedocs/gdb/Server.html)

`gdbserver` is a control program for Unix-like systems, which allows you to connect your program with a remote GDB via `target remote` or `target extended-remote`—but without linking in the usual debugging stub.

GDB and `gdbserver` communicate via either a serial line or a TCP connection, using the standard GDB remote serial protocol.

#### Running `gdbserver`

Run `gdbserver` on the target system. You need a copy of the program you want to debug, including any libraries it requires. `gdbserver` does not need your program’s symbol table, so you can strip the program if necessary to save space. **GDB on the host system does all the symbol handling**.

To use the server, you must tell it how to communicate with GDB; the name of your program; and the arguments for your program. The usual syntax is:

    target> gdbserver comm program [ args … ]

comm is either a device name (to use a serial line), or a TCP hostname and portnumber, or - or stdio to use stdin/stdout of gdbserver. For example:

    target> gdbserver host:2345 emacs foo.txt

You can choose any number you want for the port number as long as it does not conflict with any TCP ports already in use on the target system. You must use the same port number with the host GDB `target remote command`.

#### Attaching to a Running Program

On some targets, `gdbserver` can also attach to running programs. This is accomplished via the `--attach` argument. The syntax is:

    target> gdbserver --attach comm pid

#### Connecting to `gdbserver`

The basic procedure for connecting to the remote target is:

- Run GDB on the host system.
- Make sure you have the necessary symbol files. Load symbols for your application using the `file` command before you connect. Use `set sysroot` to locate target libraries (unless your GDB was compiled with the correct sysroot using `--with-sysroot`).
- Connect to your target. For TCP connections, you must start up `gdbserver` prior to using the `target` command. Otherwise you may get an error whose text depends on the host system, but which usually looks something like ‘`Connection refused`’. Don’t use the `load` command in GDB when using target remote mode, since the program is already on the target.

### [20.4 Remote Configuration](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Configuration.html)

### [20.5 Implementing a Remote Stub](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Stub.html)

The stub files provided with GDB implement the target side of the communication protocol, and the GDB side is implemented in the GDB source file `remote.c`. Normally, you can simply allow these subroutines to communicate, and ignore the details. (If you’re implementing your own stub file, you can still ignore the details: start with one of the existing stub files. `sparc-stub.c` is the best organized, and therefore the easiest to read.)
